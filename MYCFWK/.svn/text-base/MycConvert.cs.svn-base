using System;
using System.Configuration;
using System.Data;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using Myc.data.Log;

namespace Myc.data.Conversiones

{
	/// <summary>
	/// Realiza conversiones de adaptación de datos, especialmente para insertar en bases de datos.
	/// </summary>
	public class MycConvert
	{
		/// <summary>
		/// Método Constructor
		/// </summary>
		public MycConvert()
		{
		}

		/// <summary>
		/// Tipo de caracter (o caracteres) a ser utilizados para separar datos en los archivos de texto plano exportados.
		/// </summary>
		/// <example>
		/// El siguiente ejemplo convierte el DataSet w_DS en un archivo plano llamado "datos.txt" en el directorio "C:\docs\", y separa los campos por punto y coma.<br/><br/>
		/// DataSetToTXT("C:\docs\datos.txt", w_DS, <b>SisemConvert.SepCamposTXTfile.SemiColon</b>, true, false)
		/// </example>
		public enum SepCamposTXTfile
		{
			TAB,
			SemiColon,
			Quoted,
			Space
		}

		/// <summary>
		/// Transforma el XML correspondiente a un registro a guardarse en la base de datos según la estructura definida
		/// en el XML de transformación, que contiene los parámetros que espera el Stored Procedure.
		/// </summary>
		/// <param name="pStrXML">XML a transformar.</param>
		/// <param name="pStructureName">XML Template de la estructura de la BDD</param>
		/// <returns>XML transformado.</returns>
		/// <remarks>El XML de configuración debe tener como elementos los nombres de los campos del los datos leidos a introducir.
		/// Como atributo DBname debe tener el nombre del campo en la tabla en la base de datos destino.
		/// Como atributo defaultValue el valor a introducir si el dato leído viene vacío.
		/// Como atributo dataType el tipo de dato de conversión que maneja la clase MycConvert, y que son:
		/// NUMERIC = tipos numéricos (decimales y enteros); 
		/// DATETIME = Fecha y hora;
		/// STRING = los demás datos.
		/// Si los tags del archivo leído no coinciden con los de la estructura, se produce un error. Es decir que la cantidad y 
		/// nombres de los campos deben coincidir.
		/// </remarks>
		public static string AdaptToSchemaDB(string pStrXML, string pStructureName)
		{
			//string wStructureFile = ConfigurationSettings.AppSettings["StructureDB"];
            string wStructureFile = ConfigurationManager.AppSettings["StructureDB"];
        
            string wNodoError = null;

			XmlDocument wXmlStruct = new XmlDocument();
			XmlDocument wXmlData = new XmlDocument();
			StringBuilder wStrXmlOut = new StringBuilder("<XML>");

			wXmlStruct.Load(wStructureFile);
			wXmlData.LoadXml(pStrXML);

			XmlNode wNodeStruct = wXmlStruct.DocumentElement.SelectSingleNode("STRUCTURE[@name='" + pStructureName + "']");

			try
			{
				//XPath para el XML de datos
				XPathExpression exprData = wXmlData.CreateNavigator().Compile("XML");
				XPathNavigator navData = wXmlData.CreateNavigator();
				XPathNodeIterator iterData = navData.Select(exprData.Clone());


				while (iterData.MoveNext())
				{
					IHasXmlNode hxnData = (IHasXmlNode) iterData.Current;
					XmlNodeList nodosData = hxnData.GetNode().ChildNodes;


					for (int i = 0; i < nodosData.Count; i++)
					{
						//XmlNode wNodeConv = wNodeStruct.SelectSingleNode("CONV[@XMLname='Rate']");

						//XPath para el XML de estructura
						wNodoError = nodosData[i].Name; //usado para identificar dónde da error
						string wXPath = string.Format("/{0}/{1}", pStructureName, nodosData[i].Name);
						XPathExpression exprStruc = wNodeStruct.CreateNavigator().Compile(wXPath);
						XPathNavigator navStruc = wNodeStruct.CreateNavigator();
						XPathNodeIterator iterStruc = navStruc.Select(exprStruc.Clone());

						IHasXmlNode hxnStruc = (IHasXmlNode) iterStruc.Current;
						XmlNode xNode = hxnStruc.GetNode().SelectSingleNode(nodosData[i].Name);
						wNodoError = nodosData[i].Name; //usado para identificar dónde da error
						XmlAttributeCollection wXmlAttCol = xNode.Attributes;


						string valorElemento = null;
						if (nodosData[i].InnerText.Length == 0) //si el tag no tiene valor, usar el valor predeterminado en la estructura
						{
							if (wXmlAttCol["defaultValue"].Value.Length > 0)
								valorElemento = wXmlAttCol["defaultValue"].Value;

						}
						else
						{
							valorElemento = nodosData[i].InnerText;
						}
						wStrXmlOut.Append(string.Format("<{0} dataType='{1}'>{2}</{0}>", wXmlAttCol["DBname"].Value, wXmlAttCol["dataType"].Value, valorElemento));

					}
				}
				wStrXmlOut.Append("</XML>");
			}
			catch (Exception e)
			{
				MycEventLog.LogEvent("AdaptToSchemaDB", string.Format("Error al adaptar al esquema XML. nodo:[{0}]; estructura:[{1}]; {2}", wNodoError, pStructureName, e.Message), MycEventLog.LogEventType.Error);
				throw new Exception("No se pudo asignar la estructura definida al XML de datos.");
			}

			return wStrXmlOut.ToString();
		}

		#region ====== Conversiones específicas

		/// <summary>
		/// Convierte un número decimal en el sistema determinado por "numbase".
		/// </summary>
		/// <param name="iDec">Número decimal a convertir.</param>
		/// <param name="numbase">Base numérica (2, 8, 16)</param>
		/// <returns>Número convertido a la base definida por "numbase".</returns>
		public static string DecimalToBase(int iDec, int numbase)
		{
			const int base10 = 10;
			char[] cHexa = new char[] {'A', 'B', 'C', 'D', 'E', 'F'};

			string strBin = "";
			int[] result = new int[32];
			int MaxBit = 32;
			for (; iDec > 0; iDec /= numbase)
			{
				int rem = iDec%numbase;
				result[--MaxBit] = rem;
			}
			for (int i = 0; i < result.Length; i++)
				if ((int) result.GetValue(i) >= base10)
					strBin += cHexa[(int) result.GetValue(i)%base10];
				else
					strBin += result.GetValue(i);
			strBin = strBin.TrimStart(new char[] {'0'});
			return strBin;
		}

		/// <summary>
		/// Convierte un número hexadecimal en binario.
		/// </summary>
		/// <param name="Hexa">Número Hexadecimal.</param>
		/// <returns>Cadena con el número binario.</returns>
		public static string HexaToBinary(string Hexa)
		{
			int iDec = Convert.ToInt32(Hexa.ToUpper(), 16);
			const int numbase = 2;
			const int base10 = 10;
			char[] cHexa = new char[] {'A', 'B', 'C', 'D', 'E', 'F'};

			string strBin = "";
			int[] result = new int[32];
			int MaxBit = 32;
			for (; iDec > 0; iDec /= numbase)
			{
				int rem = iDec%numbase;
				result[--MaxBit] = rem;
			}
			for (int i = 0; i < result.Length; i++)
				if ((int) result.GetValue(i) >= base10)
					strBin += cHexa[(int) result.GetValue(i)%base10];
				else
					strBin += result.GetValue(i);
			strBin = strBin.TrimStart(new char[] {'0'});
			return strBin;
		}


		public static int BaseToDecimal(string sBase, int numbase)
		{
			int[] iHexaNumeric = new int[] {10, 11, 12, 13, 14, 15};
			//int[] iHexaIndices = new int[] {0, 1, 2, 3, 4, 5};
			const int asciiDiff = 48;
			const int base10 = 10;
			char[] cHexa = new char[] {'A', 'B', 'C', 'D', 'E', 'F'};
			int dec = 0;
			int b;
			int iProduct = 1;
			string sHexa = "";
			if (numbase > base10)
				for (int i = 0; i < cHexa.Length; i++)
					sHexa += cHexa.GetValue(i).ToString();
			for (int i = sBase.Length - 1; i >= 0; i--,iProduct *= numbase)
			{
				string sValue = sBase[i].ToString();
				if (sValue.IndexOfAny(cHexa) >= 0)
					b = iHexaNumeric[sHexa.IndexOf(sBase[i])];
				else
					b = (int) sBase[i] - asciiDiff;
				dec += (b*iProduct);
			}
			return dec;
		}

		/// <summary>
		/// Convierte una cadena que representa un binario en decimal.
		/// </summary>
		/// <param name="strBinary">Número binario.</param>
		/// <returns>La conversión a decimal.</returns>
		public static int BinaryToDecimal(string strBinary)
		{
			const int numbase = 2;
			int[] iHexaNumeric = new int[] {10, 11, 12, 13, 14, 15};
			//int[] iHexaIndices = new int[] {0, 1, 2, 3, 4, 5};
			const int asciiDiff = 48;
			//const int base10 = 10;
			char[] cHexa = new char[] {'A', 'B', 'C', 'D', 'E', 'F'};
			int dec = 0;
			int b;
			int iProduct = 1;
			string sHexa = "";
			//			if (numbase > base10)
			//				for (int i=0;i<cHexa.Length;i++)
			//					sHexa += cHexa.GetValue(i).ToString();

			for (int i = strBinary.Length - 1; i >= 0; i--,iProduct *= numbase)
			{
				string sValue = strBinary[i].ToString();
				if (sValue.IndexOfAny(cHexa) >= 0)
					b = iHexaNumeric[sHexa.IndexOf(strBinary[i])];
				else
					b = (int) strBinary[i] - asciiDiff;
				dec += (b*iProduct);
			}
			return dec;
		}

		#region :::: Fechas ::::

		/// <summary>
		/// Adapta una fecha al formato definido por la clave "DBdate" del App.config o Web.config.<br/>
		/// El formato de la clave "DBdate" puede tener estos parámetros:<br/>
		/// YYYY=año; MM=mes; DD=dia; h=hora; m=minuto; s=segundos; ms=milisegundos<br/>
		/// Por ejemplo, el valor de la clave en el App.config o Web.config puede ser:
		/// <code>
		/// <add key="DBdate" value="YYYY-MM-DD h:m:s:ms" />
		/// </code>
		/// </summary>
		/// <param name="p_DateTime">Fecha a formatear.</param>
		/// <returns>
		/// Si la clave "DBdate" del App.config o Web.config no existe, retorna el string en el formato "YYYY-MM-DD hh:mm:ss".<br/>
		/// Si la conversión da un error, retorna un string vacío (string.Empty).
		/// </returns>
        /// 
        public static string AdaptToTimeDB(string p_DateTime)
        {
            try
            {
                CultureInfo w_cult; //Cultura a utilizar para manejar las fechas. Si no existe una definida
                //se utiliza la predeterminada por la aplicación en el (Web.config) o la del sistema.
                try
                {
                    w_cult = CultureInfo.CreateSpecificCulture(ConfigurationManager.AppSettings["Culture"]);
                }
                catch
                {
                    w_cult = CultureInfo.CurrentCulture;
                }

                DateTime w_Date = Convert.ToDateTime(p_DateTime, w_cult.DateTimeFormat);

             //   string año = string.Format("{0:0000}", w_Date.Year);
             //   string mes = string.Format("{0:00}", w_Date.Month);
             //   string dia = string.Format("{0:00}", w_Date.Day);
                string hora = string.Format("{0:00}", w_Date.Hour);
                string min = string.Format("{0:00}", w_Date.Minute);
                string seg = string.Format("{0:00}", w_Date.Second);
                string mseg = string.Format("{0:000}", w_Date.Millisecond);

                string w_strFecha = string.Empty;

                if (ConfigurationManager.AppSettings["DBdate"] != null)
                {
                    w_strFecha = ConfigurationManager.AppSettings["DBtime"];
              //      w_strFecha = w_strFecha.Replace("YYYY", año);
              //      w_strFecha = w_strFecha.Replace("MM", mes);
              //      w_strFecha = w_strFecha.Replace("DD", dia);
                    w_strFecha = w_strFecha.Replace("hh", hora);
                    w_strFecha = w_strFecha.Replace("mm", min);
                    w_strFecha = w_strFecha.Replace("ss", seg);
                    w_strFecha = w_strFecha.Replace("ms", mseg);
                }
                else
                {
                    w_strFecha = string.Format("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00}",
                                    //           w_Date.Year, w_Date.Month, w_Date.Day,
                                               w_Date.Hour, w_Date.Minute, w_Date.Second);
                }

                CultureInfo w_cultNeutral = new CultureInfo("");
                return Convert.ToString(w_strFecha, w_cultNeutral).Trim();
            }
            catch (Exception e)
            {
                string w_msje = string.Format("Se produjo un error al intentar transformar la fecha {0}. [{1}]", p_DateTime, e.Message);
                MycEventLog.LogEvent("MycConvert", w_msje, MycEventLog.LogEventType.Warning);
                return string.Empty;
            }

        }


		public static string AdaptToDateDB(DateTime p_DateTime)
		{
			try
			{
				string año = string.Format("{0:0000}", p_DateTime.Year);
				string mes = string.Format("{0:00}", p_DateTime.Month);
				string dia = string.Format("{0:00}", p_DateTime.Day);
				string hora = string.Format("{0:00}", p_DateTime.Hour);
				string min = string.Format("{0:00}", p_DateTime.Minute);
				string seg = string.Format("{0:00}", p_DateTime.Second);
				string mseg = string.Format("{0:000}", p_DateTime.Millisecond);

				string w_strFecha = string.Empty;

				if (ConfigurationManager.AppSettings["DBdate"] != null)
				{
					w_strFecha = ConfigurationManager.AppSettings["DBdate"];
					w_strFecha = w_strFecha.Replace("YYYY", año);
					w_strFecha = w_strFecha.Replace("MM", mes);
					w_strFecha = w_strFecha.Replace("DD", dia);
					w_strFecha = w_strFecha.Replace("h", hora);
					w_strFecha = w_strFecha.Replace("m", min);
					w_strFecha = w_strFecha.Replace("s", seg);
					w_strFecha = w_strFecha.Replace("ms", mseg);
				}
				else
				{
					w_strFecha = string.Format("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00}",
					                           p_DateTime.Year, p_DateTime.Month, p_DateTime.Day,
					                           p_DateTime.Hour, p_DateTime.Minute, p_DateTime.Second);
				}

				return w_strFecha;
			}
			catch
			{
				return string.Empty;
			}
		}


		/// <summary>
		/// Adapta una fecha al formato definido por la clave "DBdate" del App.config o Web.config.<br/>
		/// El formato de la clave "DBdate" puede tener estos parámetros:<br/>
		/// YYYY=año; MM=mes; DD=dia; h=hora; m=minuto; s=segundos; ms=milisegundos<br/>
		/// Por ejemplo, el valor de la clave en el App.config o Web.config puede ser:
		/// <code>
		/// <add key="DBdate" value="YYYY-MM-DD h:m:s:ms" />
		/// </code>
		/// </summary>
		/// <param name="p_DateTime">Fecha a formatear.</param>
		/// <returns>
		/// Si la clave "DBdate" del App.config o Web.config no existe, retorna el string en el formato "YYYY-MM-DD hh:mm:ss".<br/>
		/// Si la conversión da un error, retorna un string vacío (string.Empty).
		/// </returns>
		/// <remarks>
		/// A diferencia de <see cref="AdaptToDateDB"/>, la fecha es transformada a UTC. Esto es útil para guardar en la base de datos la hora GMT,
		/// con lo que al recuperarla, se debe tener en cuenta la transformación a la hora local para ver la hora correcta,
		/// aplicando el formatter de DateTime, ToLocalTime().
		/// </remarks>
		/// <example>
		/// <code>
		/// //dr["FECHA"] contiene el valor de un campo recuperado desde un DataSet 
		/// //que trae el dato desde un query a la base de datos y lo carga en un TextBox
		/// DateTime f = Convert.ToDateTime(dr["FECHA"]).ToLocalTime().ToString();
		/// </code>
		/// </example>
		public static string AdaptToDateDB_UTC(DateTime p_DateTime)
		{
			try
			{
				p_DateTime = p_DateTime.ToUniversalTime();
				string año = string.Format("{0:0000}", p_DateTime.Year);
				string mes = string.Format("{0:00}", p_DateTime.Month);
				string dia = string.Format("{0:00}", p_DateTime.Day);
				string hora = string.Format("{0:00}", p_DateTime.Hour);
				string min = string.Format("{0:00}", p_DateTime.Minute);
				string seg = string.Format("{0:00}", p_DateTime.Second);
				string mseg = string.Format("{0:000}", p_DateTime.Millisecond);

				string w_strFecha = string.Empty;

				if (ConfigurationManager.AppSettings["DBdate"] != null)
				{
					w_strFecha = ConfigurationManager.AppSettings["DBdate"];
					w_strFecha = w_strFecha.Replace("YYYY", año);
					w_strFecha = w_strFecha.Replace("MM", mes);
					w_strFecha = w_strFecha.Replace("DD", dia);
					w_strFecha = w_strFecha.Replace("h", hora);
					w_strFecha = w_strFecha.Replace("m", min);
					w_strFecha = w_strFecha.Replace("s", seg);
					w_strFecha = w_strFecha.Replace("ms", mseg);
				}
				else
				{
					w_strFecha = string.Format("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00}",
					                           p_DateTime.Year, p_DateTime.Month, p_DateTime.Day,
					                           p_DateTime.Hour, p_DateTime.Minute, p_DateTime.Second);
				}

				return w_strFecha;
			}
			catch
			{
				return string.Empty;
			}
		}


		/// <summary>
		/// Adapta una fecha al formato definido por la clave "DBdate" del App.config o Web.config.<br/>
		/// El formato de la clave "DBdate" puede tener estos parámetros:<br/>
		/// YYYY=año; MM=mes; DD=dia; h=hora; m=minuto; s=segundos; ms=milisegundos<br/>
		/// Por ejemplo, el valor de la clave en el App.config o Web.config puede ser:
		/// <code>
		/// <add key="DBdate" value="YYYY-MM-DD h:m:s:ms" />
		/// </code>
		/// </summary>
		/// <param name="p_DateTime">Cadena de caracteres (de fecha y hora) a procesar. 
		/// Si el string a formatear no es un formato reconocible por el Formatter de DateTime, 
		/// se producirá un error.</param>
		/// <returns>
		/// Si la clave "DBdate" del App.config o Web.config no existe, retorna el string en el formato "YYYY-MM-DD hh:mm:ss".<br/>
		/// </returns>
		public static string AdaptToDateDB(string p_DateTime)
		{
			try
			{
				CultureInfo w_cult; //Cultura a utilizar para manejar las fechas. Si no existe una definida
				//se utiliza la predeterminada por la aplicación en el (Web.config) o la del sistema.
				try
				{
					w_cult = CultureInfo.CreateSpecificCulture(ConfigurationManager.AppSettings["Culture"]);
				}
				catch
				{
					w_cult = CultureInfo.CurrentCulture;
				}

				DateTime w_Date = Convert.ToDateTime(p_DateTime, w_cult.DateTimeFormat);

				string año = string.Format("{0:0000}", w_Date.Year);
				string mes = string.Format("{0:00}", w_Date.Month);
				string dia = string.Format("{0:00}", w_Date.Day);
				string hora = string.Format("{0:00}", w_Date.Hour);
				string min = string.Format("{0:00}", w_Date.Minute);
				string seg = string.Format("{0:00}", w_Date.Second);
				string mseg = string.Format("{0:000}", w_Date.Millisecond);

				string w_strFecha = string.Empty;

				if (ConfigurationManager.AppSettings["DBdate"] != null)
				{
					w_strFecha = ConfigurationManager.AppSettings["DBdate"];
					w_strFecha = w_strFecha.Replace("YYYY", año);
					w_strFecha = w_strFecha.Replace("MM", mes);
					w_strFecha = w_strFecha.Replace("DD", dia);
					w_strFecha = w_strFecha.Replace("h", hora);
					w_strFecha = w_strFecha.Replace("m", min);
					w_strFecha = w_strFecha.Replace("s", seg);
					w_strFecha = w_strFecha.Replace("ms", mseg);
				}
				else
				{
					w_strFecha = string.Format("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00}",
					                           w_Date.Year, w_Date.Month, w_Date.Day,
					                           w_Date.Hour, w_Date.Minute, w_Date.Second);
				}

				CultureInfo w_cultNeutral = new CultureInfo("");
				return Convert.ToString(w_strFecha, w_cultNeutral).Trim();
			}
			catch (Exception e)
			{
				string w_msje = string.Format("Se produjo un error al intentar transformar la fecha {0}. [{1}]", p_DateTime, e.Message);
				MycEventLog.LogEvent("MycConvert", w_msje, MycEventLog.LogEventType.Warning);
				return string.Empty;
			}

		}

		/// <summary>
		/// Adapta una fecha al formato definido por la clave "DBdate" del App.config o Web.config.<br/>
		/// El formato de la clave "DBdate" puede tener estos parámetros:<br/>
		/// YYYY=año; MM=mes; DD=dia; h=hora; m=minuto; s=segundos; ms=milisegundos<br/>
		/// Por ejemplo, el valor de la clave en el App.config o Web.config puede ser:
		/// <code>
		/// <add key="DBdate" value="YYYY-MM-DD h:m:s:ms" />
		/// </code>
		/// </summary>
		/// <param name="p_DateTime">Cadena de caracteres (de fecha y hora) a procesar. 
		/// Si el string a formatear no es un formato reconocible por el Formatter de DateTime, 
		/// se producirá un error.</param>
		/// <returns>
		/// Si la clave "DBdate" del App.config o Web.config no existe, retorna el string en el formato "YYYY-MM-DD hh:mm:ss".<br/>
		/// </returns>
		/// <remarks>
		/// A diferencia de <see cref="AdaptToDateDB"/>, la fecha es transformada a UTC. Esto es útil para guardar en la base de datos la hora GMT,
		/// con lo que al recuperarla, se debe tener en cuenta la transformación a la hora local para ver la hora correcta,
		/// aplicando el formatter de DateTime, ToLocalTime().
		/// </remarks>
		/// <example>
		/// <code>
		/// //dr["FECHA"] contiene el valor de un campo recuperado desde un DataSet 
		/// //que trae el dato desde un query a la base de datos y lo carga en un TextBox
		/// DateTime f = Convert.ToDateTime(dr["FECHA"]).ToLocalTime().ToString();
		/// </code>
		/// </example>
		public static string AdaptToDateDB_UTC(string p_DateTime)
		{
			try
			{
				CultureInfo w_cult; //Cultura a utilizar para manejar las fechas. Si no existe una definida
				//se utiliza la predeterminada por la aplicación en el (Web.config) o la del sistema.
				try
				{
					w_cult = CultureInfo.CreateSpecificCulture(ConfigurationManager.AppSettings["Culture"]);
				}
				catch
				{
					w_cult = CultureInfo.CurrentCulture;
				}

				DateTime w_Date = Convert.ToDateTime(p_DateTime, w_cult.DateTimeFormat).ToUniversalTime();

				string año = string.Format("{0:0000}", w_Date.Year);
				string mes = string.Format("{0:00}", w_Date.Month);
				string dia = string.Format("{0:00}", w_Date.Day);
				string hora = string.Format("{0:00}", w_Date.Hour);
				string min = string.Format("{0:00}", w_Date.Minute);
				string seg = string.Format("{0:00}", w_Date.Second);
				string mseg = string.Format("{0:000}", w_Date.Millisecond);

				string w_strFecha = string.Empty;

				if (ConfigurationManager.AppSettings["DBdate"] != null)
				{
					w_strFecha = ConfigurationManager.AppSettings["DBdate"];
					w_strFecha = w_strFecha.Replace("YYYY", año);
					w_strFecha = w_strFecha.Replace("MM", mes);
					w_strFecha = w_strFecha.Replace("DD", dia);
					w_strFecha = w_strFecha.Replace("h", hora);
					w_strFecha = w_strFecha.Replace("m", min);
					w_strFecha = w_strFecha.Replace("s", seg);
					w_strFecha = w_strFecha.Replace("ms", mseg);
				}
				else
				{
					w_strFecha = string.Format("{0:0000}-{1:00}-{2:00} {3:00}:{4:00}:{5:00}",
					                           w_Date.Year, w_Date.Month, w_Date.Day,
					                           w_Date.Hour, w_Date.Minute, w_Date.Second);
				}

				CultureInfo w_cultNeutral = new CultureInfo("");
				return Convert.ToString(w_strFecha, w_cultNeutral).Trim();
			}
			catch (Exception e)
			{
				string w_msje = string.Format("Se produjo un error al intentar transformar la fecha {0}. [{1}]", p_DateTime, e.Message);
				MycEventLog.LogEvent("MycConvert", w_msje, MycEventLog.LogEventType.Warning);
				return string.Empty;
			}

		}

		#endregion

		/// <summary>
		/// Reemplaza la coma decimal por punto decimal.
		/// </summary>
		/// <param name="pNumber"></param>
		/// <returns></returns>
		public static string AdaptToDecimalDB(string pNumber)
		{
			/*
			decimal wNumber = Convert.ToDecimal (pNumber);
			CultureInfo wCult = new CultureInfo("");
			return wNumber.ToString (wCult);
			*/
			if (pNumber.Length == 0)
				pNumber = "0";

			return pNumber.Replace(",", ".");
		}

		/// <summary>
		/// Convierte un string a decimal utilizando invariant culture.
		/// La coma decimal es reemplazada por punto decimal.
		/// </summary>
		/// <param name="p_Number"></param>
		/// <returns></returns>
		public static Decimal AdaptToDecimal(string p_Number)
		{
			CultureInfo w_cult = new CultureInfo("");

			if (p_Number.Length == 0)
				p_Number = "0";

			return Convert.ToDecimal(p_Number.Replace(",", "."), w_cult);
		}


		/// <summary>
		/// Por el momento no produce ningún efecto. Existe por una posible funcionalidad futura.
		/// </summary>
		/// <param name="pString"></param>
		/// <returns>El string tal cual fue enviado.</returns>
		public static string AdaptToStringDB(string pString)
		{
			return pString;
		}


		/// <summary>
		/// Quita todas las claves primarias (PK) definidas en un DataSet de un tipo determinado, 
		/// devolviendo uno con idéntico esquema, pero sin ninguna columna definida como PK.
		/// </summary>
		/// <param name="p_DSmodel">DataSet original, que contiene columnas con claver primarias (PK) definidas.</param>
		/// <returns>DataSet igual al de p_DSmodel, pero con ninguna columna definida como PK</returns>
		public static DataSet setDatasetWithoutKey(DataSet p_DSmodel)
		{
			DataSet dsRes = new DataSet();
			foreach (DataTable dt in p_DSmodel.Tables)
			{
				DataTable dtRes = new DataTable(dt.TableName);
				foreach (DataColumn dc in dt.Columns)
					dtRes.Columns.Add(dc.ColumnName);

				dsRes.Tables.Add(dtRes);
			}

			return dsRes;
		}

		#endregion

		#region ====== Conversiones de archivo

		/// <summary>
		/// Convierte un DataSet de una tabla a un archivo de texto.
		/// </summary>
		/// <param name="pAPPpath">Path y nombre del archivo.</param>
		/// <param name="pDS">Dataset a guardar como archivo de texto.</param>
		/// <param name="pSeparador">Tipo de separador de campos:
		/// SemiColon = punto y coma.
		/// Quoted = campos entre comillas, separados por punto y coma.
		/// Space = campos separados por un espacio.
		/// TAB = campos separados por Tabulación</param>
		/// <param name="pOverwriteIfExists">"true" si se sobreescribe el archivo en caso de que exista. 
		/// Si es "false" y el archivo existe, el archivo no se altera y se devuelve un cero.
		/// En caso de que pAppend sea "true", y el archivo existe, los registros son agregados al archivo existente.</param>
		/// <param name="pAppend">Los registros son agregados al archivo existente. 
		/// Si no existe el archivo, entonces se crea. </param>
		/// <returns>Cantidad de registros (líneas) que se agregaron al archivo de texto.</returns>
		public static int DataSetToTXT(string pAPPpath, DataSet pDS, SepCamposTXTfile pSeparador, bool pOverwriteIfExists, bool pAppend)
		{
			int lineasEscritas = 0;

			if (!File.Exists(pAPPpath))
				pOverwriteIfExists = true;

			if (pOverwriteIfExists || pAppend)
			{
				StreamWriter sW = new StreamWriter(pAPPpath, pAppend);

				for (int i = 0; i < pDS.Tables[0].Rows.Count; i++)
				{
					DataRow dr = pDS.Tables[0].Rows[i];

					string linea = string.Empty;

					switch (pSeparador)
					{
						case SepCamposTXTfile.Quoted:
							linea = "\"";
							break;
						case SepCamposTXTfile.SemiColon:
							break;
						case SepCamposTXTfile.TAB:
							break;
						case SepCamposTXTfile.Space:
							break;
					}


					for (int j = 0; j < pDS.Tables[0].Columns.Count; j++)
					{
						string wValorDato = null;
						switch (pSeparador)
						{
							case SepCamposTXTfile.Quoted:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato + "\"";
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += ";\"";
								break;

							case SepCamposTXTfile.SemiColon:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += ";";
								break;

							case SepCamposTXTfile.Space:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += " ";
								break;

							case SepCamposTXTfile.TAB:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += (char) 9;
								break;
						}
					}
					sW.WriteLine(linea);
					lineasEscritas = i;
				}
				sW.Close();
			}
			else
			{
				lineasEscritas = 0;
			}

			if (lineasEscritas > 0)
				lineasEscritas++;

			return lineasEscritas;
		}


		/// <summary>
		/// Convierte un DataSet de una tabla a un archivo de texto.
		/// </summary>
		/// <param name="pAPPpath">Path y nombre del archivo.</param>
		/// <param name="pDS">Dataset a guardar como archivo de texto.</param>
		/// <param name="pSeparador">Cualquier string que quiera utilizarse como separador de campos.
		///</param>
		/// <param name="pOverwriteIfExists">"true" si se sobreescribe el archivo en caso de que exista. 
		/// Si es "false" y el archivo existe, el archivo no se altera y se devuelve un cero.
		/// En caso de que pAppend sea "true", y el archivo existe, los registros son agregados al archivo existente.</param>
		/// <param name="pAppend">Los registros son agregados al archivo existente. 
		/// Si no existe el archivo, entonces se crea. </param>
		/// <returns>Cantidad de registros (líneas) que se agregaron al archivo de texto.</returns>
		public static int DataSetToTXT(string pAPPpath, DataSet pDS, string pSeparador, bool pOverwriteIfExists, bool pAppend)
		{
			int lineasEscritas = 0;

			if (!File.Exists(pAPPpath))
				pOverwriteIfExists = true;

			if (pOverwriteIfExists || pAppend)
			{
				StreamWriter sW = new StreamWriter(pAPPpath, pAppend);

				for (int i = 0; i < pDS.Tables[0].Rows.Count; i++)
				{
					DataRow dr = pDS.Tables[0].Rows[i];

					string linea = string.Empty;

					for (int j = 0; j < pDS.Tables[0].Columns.Count; j++)
					{
						string wValorDato = dr[j].ToString();
						if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
							wValorDato = AdaptToDateDB(wValorDato);

						linea += wValorDato;
						if (j < pDS.Tables[0].Columns.Count - 1)
							linea += pSeparador;
					}
					sW.WriteLine(linea);
					lineasEscritas = i;
				}
				sW.Close();
			}
			else
			{
				lineasEscritas = 0;
			}
			if (lineasEscritas > 0)
				lineasEscritas++;

			return lineasEscritas;
		}


		/// <summary>
		/// Convierte un DataSet de una tabla a un archivo de texto.
		/// </summary>
		/// <param name="pAPPpath">Path y nombre del archivo.</param>
		/// <param name="pDS">Dataset a guardar como archivo de texto.</param>
		/// <param name="pSeparador">Caracter ASCII que quiera utilizarse como separador de campos.
		///</param>
		/// <param name="pOverwriteIfExists">"true" si se sobreescribe el archivo en caso de que exista. 
		/// Si es "false" y el archivo existe, el archivo no se altera y se devuelve un cero.
		/// En caso de que pAppend sea "true", y el archivo existe, los registros son agregados al archivo existente.</param>
		/// <param name="pAppend">Los registros son agregados al archivo existente. 
		/// Si no existe el archivo, entonces se crea. </param>
		/// <returns>Cantidad de registros (líneas) que se agregaron al archivo de texto.</returns>
		public static int DataSetToTXT(string pAPPpath, DataSet pDS, int pSeparador, bool pOverwriteIfExists, bool pAppend)
		{
			int lineasEscritas = 0;

			if (!File.Exists(pAPPpath))
				pOverwriteIfExists = true;

			if (pOverwriteIfExists || pAppend)
			{
				StreamWriter sW = new StreamWriter(pAPPpath, pAppend);

				for (int i = 0; i < pDS.Tables[0].Rows.Count; i++)
				{
					DataRow dr = pDS.Tables[0].Rows[i];

					string linea = string.Empty;

					for (int j = 0; j < pDS.Tables[0].Columns.Count; j++)
					{
						string wValorDato = dr[j].ToString();
						if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
							wValorDato = AdaptToDateDB(wValorDato);

						linea += wValorDato;
						if (j < pDS.Tables[0].Columns.Count - 1)
							linea += (char) pSeparador;
					}
					sW.WriteLine(linea);
					lineasEscritas = i;
				}
				sW.Close();
			}
			else
			{
				lineasEscritas = 0;
			}

			if (lineasEscritas > 0)
				lineasEscritas++;

			return lineasEscritas;
		}


		//-----------------------------------------

		/// <summary>
		/// Convierte un DataSet de una tabla a un archivo de texto.
		/// </summary>
		/// <param name="pAPPpath">Path y nombre del archivo.</param>
		/// <param name="pDS">Dataset a guardar como archivo de texto.</param>
		/// <param name="pSeparador">Tipo de separador de campos:
		/// SemiColon = punto y coma.
		/// Quoted = campos entre comillas, separados por punto y coma.
		/// Space = campos separados por un espacio.
		/// TAB = campos separados por Tabulación</param>
		/// <param name="pCamposEncabezado">Nombres de los campos (separados por comas) a incluir en la primera fila del archivo.</param>
		/// <param name="pOverwriteIfExists">"true" si se sobreescribe el archivo en caso de que exista. 
		/// Si es "false" y el archivo existe, el archivo no se altera y se devuelve un cero.
		/// En caso de que pAppend sea "true", y el archivo existe, los registros son agregados al archivo existente.</param>
		/// <param name="pAppend">Los registros son agregados al archivo existente. 
		/// Si no existe el archivo, entonces se crea. </param>
		/// <returns>Cantidad de registros (líneas) que se agregaron al archivo de texto.</returns>
		public static int DataSetToTXT(string pAPPpath, DataSet pDS, SepCamposTXTfile pSeparador, string pCamposEncabezado, bool pOverwriteIfExists, bool pAppend)
		{
			int lineasEscritas = 0;

			if (!File.Exists(pAPPpath))
				pOverwriteIfExists = true;

			string linea = string.Empty;

			if (pOverwriteIfExists || pAppend)
			{
				StreamWriter sW = new StreamWriter(pAPPpath, pAppend);

				switch (pSeparador)
				{
					case SepCamposTXTfile.Quoted:
						linea = "\"";
						pCamposEncabezado = "\"" + pCamposEncabezado.Replace(",", (linea + ";" + linea)) + "\"";
						break;
					case SepCamposTXTfile.SemiColon:
						pCamposEncabezado = pCamposEncabezado.Replace(",", ";");
						break;
					case SepCamposTXTfile.TAB:
						string sep = "" + (char) 9;
						pCamposEncabezado = pCamposEncabezado.Replace(",", sep);
						break;
					case SepCamposTXTfile.Space:
						pCamposEncabezado = pCamposEncabezado.Replace(",", " ");
						break;
				}
				sW.WriteLine(pCamposEncabezado); //escribe encabezado				

				for (int i = 0; i < pDS.Tables[0].Rows.Count; i++)
				{
					DataRow dr = pDS.Tables[0].Rows[i];

					linea = string.Empty;

					for (int j = 0; j < pDS.Tables[0].Columns.Count; j++)
					{
						string wValorDato = null;
						switch (pSeparador)
						{
							case SepCamposTXTfile.Quoted:
								if (linea.Length == 0)
									linea = "\"";

								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato + "\"";
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += ";\"";
								break;

							case SepCamposTXTfile.SemiColon:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += ";";
								break;

							case SepCamposTXTfile.Space:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += " ";
								break;

							case SepCamposTXTfile.TAB:
								wValorDato = dr[j].ToString();
								if (dr[j].GetType().ToString().CompareTo("System.DateTime") == 0)
									wValorDato = AdaptToDateDB(wValorDato);

								linea += wValorDato;
								if (j < pDS.Tables[0].Columns.Count - 1)
									linea += (char) 9;
								break;
						}
					}
					sW.WriteLine(linea);
					lineasEscritas = i;
				}
				sW.Close();
			}
			else
			{
				lineasEscritas = 0;
			}

			if (lineasEscritas > 0)
				lineasEscritas++;

			return lineasEscritas;
		}


		/// <summary>
		/// Guarda un DataSet en un archivo con formato XML.
		/// </summary>
		/// <param name="pAPPpath">Path y nombre del archivo.</param>
		/// <param name="pDS">Dataset a guardar como archivo XML.</param>
		/// <returns>Cantidad de registros (filas) del DataSet.</returns>
		public static int DataSetToXML(string pAPPpath, DataSet pDS)
		{
			XmlDocument wXML = new XmlDocument();
			wXML.LoadXml(pDS.GetXml());
			wXML.Save(pAPPpath);

			return pDS.Tables[0].Rows.Count;
		}

		#endregion

		#region ====== Levantar XML recursos

		/// <summary>
		/// Lee una valor de un archivo XML (normalmente usado para configuración).
		/// El path físico y nombre del archivo se toma del archivo de configuración de la aplicación
		/// (web.config o app.config), bajo la clave "XMLresFile". Si el valor de esta clave es solamente
		/// el nombre del archivo (sin el path), el mismo debe estar en la carpeta bin de la aplicación. 
		/// </summary>
		/// <param name="pXMLkey">Clave a leer (tag xml)</param>
		/// <returns>Valor del tag pasado como clave.
		/// Si el elemento no se encuentra, o no existe un valor para la clave "XMLresFile" en el archivo
		/// de configuración, retorna NULL</returns>
		public static string getXMLresKey(string pXMLkey)
		{
			string w_ConfigFile = ConfigurationManager.AppSettings["XMLresFile"];
			string w_strRet = null;

			if (w_ConfigFile != null)
			{
				//string sElem = "/RES/" + pXMLkey;
				try
				{
					StreamReader sr = new StreamReader(w_ConfigFile);
					XmlDocument doc = new XmlDocument();
					doc.LoadXml(sr.ReadToEnd());
					sr.Close();

					string sElem = string.Format("/{0}/{1}", doc.FirstChild.Name, pXMLkey);
					XmlNode node = doc.SelectSingleNode(sElem);
					try
					{
						w_strRet = node.InnerText;
					}
					catch
					{
						w_strRet = null;
					}
				}
				catch (Exception e)
				{
					string msje = string.Format("Error al leer el archivo {0}", w_ConfigFile);
					throw new Exception(msje, e);
				}
			}

			return w_strRet;
		}


		/// <summary>
		/// Extrae el valor de un nodo de un documento XML.
		/// </summary>
		/// <param name="pXMLdoc">Documento XML</param>
		/// <param name="pNodePath">Path del nodo a extraer el valor.</param>
		/// <returns>Nodo XML</returns>
		public static string getXMLNodeValue(XmlDocument pXMLdoc, string pNodePath)
		{
			XPathExpression expr = pXMLdoc.CreateNavigator().Compile(pNodePath);
			XPathNavigator nav = pXMLdoc.CreateNavigator();
			XPathNodeIterator RateChange = nav.Select(expr.Clone());

			IHasXmlNode hxn = (IHasXmlNode) RateChange.Current;
			XmlNode nodo = hxn.GetNode().SelectSingleNode(pNodePath);

			if (nodo != null)
				return nodo.InnerXml;
			else
				return string.Empty;
		}


		/// <summary>
		/// Extrae el valor de un nodo de un archivo XML, y lo devuelve en un string.
		/// </summary>
		/// <param name="pPathXMLfile">Nombre y ruta del archivo XML.</param>
		/// <param name="pNodePath">Path del nodo a extraer el valor.</param>
		/// <returns>Nodo XML. Si no existen nodos definidos en pNodePath, devuelve una cadena vacía.</returns>
		public static string getXMLNodeValueFromFile(string pPathXMLfile, string pNodePath)
		{
			StreamReader sr = new StreamReader(pPathXMLfile);
			XmlDocument doc = new XmlDocument();
			doc.LoadXml(sr.ReadToEnd());
			sr.Close();

			XPathExpression expr = doc.CreateNavigator().Compile(pNodePath);
			XPathNavigator nav = doc.CreateNavigator();
			XPathNodeIterator RateChange = nav.Select(expr.Clone());

			IHasXmlNode hxn = (IHasXmlNode) RateChange.Current;
			XmlNode nodo = hxn.GetNode().SelectSingleNode(pNodePath);

			if (nodo != null)
				return nodo.InnerXml;
			else
				return string.Empty;
		}


		/// <summary>
		/// Extrae el valor de un nodo de un archivo XML, y lo devuelve en un objeto XML.
		/// </summary>
		/// <param name="pPathXMLfile">Nombre y ruta del archivo XML.</param>
		/// <param name="pNodePath">Path del nodo a extraer el valor.</param>
		/// <param name="p_RootName">Nombre del tag raíz del documento XML a retornar</param>
		/// <returns>Nodos XML. Si no existen nodos definidos en pNodePath, devuelve el objeto XML vacío.</returns>
		public static XmlDocument getXMLNodeValueFromFile(string pPathXMLfile, string pNodePath, string p_RootName)
		{
			StreamReader sr = new StreamReader(pPathXMLfile);
			XmlDocument doc = new XmlDocument();
			doc.LoadXml(sr.ReadToEnd());
			sr.Close();

			XPathExpression expr = doc.CreateNavigator().Compile(pNodePath);
			XPathNavigator nav = doc.CreateNavigator();
			XPathNodeIterator RateChange = nav.Select(expr.Clone());

			IHasXmlNode hxn = (IHasXmlNode) RateChange.Current;
			XmlNode nodo = hxn.GetNode().SelectSingleNode(pNodePath);

			XmlDocument w_retDoc = new XmlDocument();

			if (nodo != null)
			{
				string w_XML = string.Format("<{0}>{1}</{0}>", p_RootName, nodo.InnerXml);
				w_retDoc.LoadXml(w_XML);
			}

			return w_retDoc;
		}


		/// <summary>
		/// Extrae el valor de un nodo de un string con formato XML.
		/// </summary>
		/// <param name="p_XML">String XML bien formado.</param>
		/// <param name="pNodePath">Path del nodo a extraer el valor.</param>
		/// <returns></returns>
		public static string getXMLNodeValue(string p_XML, string pNodePath)
		{
			XmlDocument xDoc = new XmlDocument();
			xDoc.LoadXml(p_XML);
			XPathExpression expr = xDoc.CreateNavigator().Compile(pNodePath);
			XPathNavigator nav = xDoc.CreateNavigator();
			XPathNodeIterator RateChange = nav.Select(expr.Clone());

			IHasXmlNode hxn = (IHasXmlNode) RateChange.Current;
			XmlNode nodo = hxn.GetNode().SelectSingleNode(pNodePath);

			if (nodo != null)
				return nodo.InnerXml;
			else
				return string.Empty;
		}

		#endregion

		#region Encriptación

		//		public class EncDec 
		//		{
		// Encrypt a byte array into a byte array using a key and an IV 
		public static byte[] Encrypt(byte[] clearData, byte[] Key, byte[] IV)
		{
			// Create a MemoryStream to accept the encrypted bytes 
			MemoryStream ms = new MemoryStream();

			// Create a symmetric algorithm. 
			// We are going to use Rijndael because it is strong and
			// available on all platforms. 
			// You can use other algorithms, to do so substitute the
			// next line with something like 
			//      TripleDES alg = TripleDES.Create(); 
			Rijndael alg = Rijndael.Create();

			// Now set the key and the IV. 
			// We need the IV (Initialization Vector) because
			// the algorithm is operating in its default 
			// mode called CBC (Cipher Block Chaining).
			// The IV is XORed with the first block (8 byte) 
			// of the data before it is encrypted, and then each
			// encrypted block is XORed with the 
			// following block of plaintext.
			// This is done to make encryption more secure. 

			// There is also a mode called ECB which does not need an IV,
			// but it is much less secure. 
			alg.Key = Key;
			alg.IV = IV;

			// Create a CryptoStream through which we are going to be
			// pumping our data. 
			// CryptoStreamMode.Write means that we are going to be
			// writing data to the stream and the output will be written
			// in the MemoryStream we have provided. 
			CryptoStream cs = new CryptoStream(ms,
			                                   alg.CreateEncryptor(), CryptoStreamMode.Write);

			// Write the data and make it do the encryption 
			cs.Write(clearData, 0, clearData.Length);

			// Close the crypto stream (or do FlushFinalBlock). 
			// This will tell it that we have done our encryption and
			// there is no more data coming in, 
			// and it is now a good time to apply the padding and
			// finalize the encryption process. 
			cs.Close();

			// Now get the encrypted data from the MemoryStream.
			// Some people make a mistake of using GetBuffer() here,
			// which is not the right way. 
			byte[] encryptedData = ms.ToArray();

			return encryptedData;
		}


		// Encrypt a string into a string using a password 
		//    Uses Encrypt(byte[], byte[], byte[]) 

		public static string Encrypt(string clearText, string Password)
		{
			// First we need to turn the input string into a byte array. 
			byte[] clearBytes =
				System.Text.Encoding.Unicode.GetBytes(clearText);

			// Then, we need to turn the password into Key and IV 
			// We are using salt to make it harder to guess our key
			// using a dictionary attack - 
			// trying to guess a password by enumerating all possible words. 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
			                                                  		0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});

			// Now get the key/IV and do the encryption using the
			// function that accepts byte arrays. 
			// Using PasswordDeriveBytes object we are first getting
			// 32 bytes for the Key 
			// (the default Rijndael key length is 256bit = 32bytes)
			// and then 16 bytes for the IV. 
			// IV should always be the block size, which is by default
			// 16 bytes (128 bit) for Rijndael. 
			// If you are using DES/TripleDES/RC2 the block size is
			// 8 bytes and so should be the IV size. 
			// You can also read KeySize/BlockSize properties off
			// the algorithm to find out the sizes. 
			byte[] encryptedData = Encrypt(clearBytes,
			                               pdb.GetBytes(32), pdb.GetBytes(16));

			// Now we need to turn the resulting byte array into a string. 
			// A common mistake would be to use an Encoding class for that.
			//It does not work because not all byte values can be
			// represented by characters. 
			// We are going to be using Base64 encoding that is designed
			//exactly for what we are trying to do. 
			return Convert.ToBase64String(encryptedData);

		}


		// Encrypt bytes into bytes using a password 
		//    Uses Encrypt(byte[], byte[], byte[]) 

		public static byte[] Encrypt(byte[] clearData, string Password)
		{
			// We need to turn the password into Key and IV. 
			// We are using salt to make it harder to guess our key
			// using a dictionary attack - 
			// trying to guess a password by enumerating all possible words. 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
			                                                  		0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});

			// Now get the key/IV and do the encryption using the function
			// that accepts byte arrays. 
			// Using PasswordDeriveBytes object we are first getting
			// 32 bytes for the Key 
			// (the default Rijndael key length is 256bit = 32bytes)
			// and then 16 bytes for the IV. 
			// IV should always be the block size, which is by default
			// 16 bytes (128 bit) for Rijndael. 
			// If you are using DES/TripleDES/RC2 the block size is 8
			// bytes and so should be the IV size. 
			// You can also read KeySize/BlockSize properties off the
			// algorithm to find out the sizes. 
			return Encrypt(clearData, pdb.GetBytes(32), pdb.GetBytes(16));

		}


		// Encrypt a file into another file using a password 
		public static void Encrypt(string fileIn,
		                           string fileOut, string Password)
		{
			// First we are going to open the file streams 
			FileStream fsIn = new FileStream(fileIn,
			                                 FileMode.Open, FileAccess.Read);
			FileStream fsOut = new FileStream(fileOut,
			                                  FileMode.OpenOrCreate, FileAccess.Write);

			// Then we are going to derive a Key and an IV from the
			// Password and create an algorithm 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
			                                                  		0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});

			Rijndael alg = Rijndael.Create();
			alg.Key = pdb.GetBytes(32);
			alg.IV = pdb.GetBytes(16);

			// Now create a crypto stream through which we are going
			// to be pumping data. 
			// Our fileOut is going to be receiving the encrypted bytes. 
			CryptoStream cs = new CryptoStream(fsOut,
			                                   alg.CreateEncryptor(), CryptoStreamMode.Write);

			// Now will will initialize a buffer and will be processing
			// the input file in chunks. 
			// This is done to avoid reading the whole file (which can
			// be huge) into memory. 
			int bufferLen = 4096;
			byte[] buffer = new byte[bufferLen];
			int bytesRead;

			do
			{
				// read a chunk of data from the input file 
				bytesRead = fsIn.Read(buffer, 0, bufferLen);

				// encrypt it 
				cs.Write(buffer, 0, bytesRead);
			} while (bytesRead != 0);

			// close everything 

			// this will also close the unrelying fsOut stream
			cs.Close();
			fsIn.Close();
		}


		// Decrypt a byte array into a byte array using a key and an IV 
		public static byte[] Decrypt(byte[] cipherData,
		                             byte[] Key, byte[] IV)
		{
			// Create a MemoryStream that is going to accept the
			// decrypted bytes 
			MemoryStream ms = new MemoryStream();

			// Create a symmetric algorithm. 
			// We are going to use Rijndael because it is strong and
			// available on all platforms. 
			// You can use other algorithms, to do so substitute the next
			// line with something like 
			//     TripleDES alg = TripleDES.Create(); 
			Rijndael alg = Rijndael.Create();

			// Now set the key and the IV. 
			// We need the IV (Initialization Vector) because the algorithm
			// is operating in its default 
			// mode called CBC (Cipher Block Chaining). The IV is XORed with
			// the first block (8 byte) 
			// of the data after it is decrypted, and then each decrypted
			// block is XORed with the previous 
			// cipher block. This is done to make encryption more secure. 
			// There is also a mode called ECB which does not need an IV,
			// but it is much less secure. 
			alg.Key = Key;
			alg.IV = IV;

			// Create a CryptoStream through which we are going to be
			// pumping our data. 
			// CryptoStreamMode.Write means that we are going to be
			// writing data to the stream 
			// and the output will be written in the MemoryStream
			// we have provided. 
			CryptoStream cs = new CryptoStream(ms,
			                                   alg.CreateDecryptor(), CryptoStreamMode.Write);

			// Write the data and make it do the decryption 
			cs.Write(cipherData, 0, cipherData.Length);

			// Close the crypto stream (or do FlushFinalBlock). 
			// This will tell it that we have done our decryption
			// and there is no more data coming in, 
			// and it is now a good time to remove the padding
			// and finalize the decryption process. 
			cs.Close();

			// Now get the decrypted data from the MemoryStream. 
			// Some people make a mistake of using GetBuffer() here,
			// which is not the right way. 
			byte[] decryptedData = ms.ToArray();

			return decryptedData;
		}


		// Decrypt a string into a string using a password 
		//    Uses Decrypt(byte[], byte[], byte[]) 

		public static string Decrypt(string cipherText, string Password)
		{
			// First we need to turn the input string into a byte array. 
			// We presume that Base64 encoding was used 
			byte[] cipherBytes = Convert.FromBase64String(cipherText);

			// Then, we need to turn the password into Key and IV 
			// We are using salt to make it harder to guess our key
			// using a dictionary attack - 
			// trying to guess a password by enumerating all possible words. 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65,
			                                                  		0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});

			// Now get the key/IV and do the decryption using
			// the function that accepts byte arrays. 
			// Using PasswordDeriveBytes object we are first
			// getting 32 bytes for the Key 
			// (the default Rijndael key length is 256bit = 32bytes)
			// and then 16 bytes for the IV. 
			// IV should always be the block size, which is by
			// default 16 bytes (128 bit) for Rijndael. 
			// If you are using DES/TripleDES/RC2 the block size is
			// 8 bytes and so should be the IV size. 
			// You can also read KeySize/BlockSize properties off
			// the algorithm to find out the sizes. 
			byte[] decryptedData = Decrypt(cipherBytes,
			                               pdb.GetBytes(32), pdb.GetBytes(16));

			// Now we need to turn the resulting byte array into a string. 
			// A common mistake would be to use an Encoding class for that.
			// It does not work 
			// because not all byte values can be represented by characters. 
			// We are going to be using Base64 encoding that is 
			// designed exactly for what we are trying to do. 
			return System.Text.Encoding.Unicode.GetString(decryptedData);
		}


		// Decrypt bytes into bytes using a password 
		//    Uses Decrypt(byte[], byte[], byte[]) 

		public static byte[] Decrypt(byte[] cipherData, string Password)
		{
			// We need to turn the password into Key and IV. 
			// We are using salt to make it harder to guess our key
			// using a dictionary attack - 
			// trying to guess a password by enumerating all possible words. 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
			                                                  		0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});

			// Now get the key/IV and do the Decryption using the 
			//function that accepts byte arrays. 
			// Using PasswordDeriveBytes object we are first getting
			// 32 bytes for the Key 
			// (the default Rijndael key length is 256bit = 32bytes)
			// and then 16 bytes for the IV. 
			// IV should always be the block size, which is by default
			// 16 bytes (128 bit) for Rijndael. 
			// If you are using DES/TripleDES/RC2 the block size is
			// 8 bytes and so should be the IV size. 

			// You can also read KeySize/BlockSize properties off the
			// algorithm to find out the sizes. 
			return Decrypt(cipherData, pdb.GetBytes(32), pdb.GetBytes(16));
		}


		// Decrypt a file into another file using a password 
		public static void Decrypt(string fileIn,
		                           string fileOut, string Password)
		{
			// First we are going to open the file streams 
			FileStream fsIn = new FileStream(fileIn,
			                                 FileMode.Open, FileAccess.Read);
			FileStream fsOut = new FileStream(fileOut,
			                                  FileMode.OpenOrCreate, FileAccess.Write);

			// Then we are going to derive a Key and an IV from
			// the Password and create an algorithm 
			PasswordDeriveBytes pdb = new PasswordDeriveBytes(Password,
			                                                  new byte[]
			                                                  	{
			                                                  		0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d,
			                                                  		0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76
			                                                  	});
			Rijndael alg = Rijndael.Create();

			alg.Key = pdb.GetBytes(32);
			alg.IV = pdb.GetBytes(16);

			// Now create a crypto stream through which we are going
			// to be pumping data. 
			// Our fileOut is going to be receiving the Decrypted bytes. 
			CryptoStream cs = new CryptoStream(fsOut,
			                                   alg.CreateDecryptor(), CryptoStreamMode.Write);

			// Now will will initialize a buffer and will be 
			// processing the input file in chunks. 
			// This is done to avoid reading the whole file (which can be
			// huge) into memory. 
			int bufferLen = 4096;
			byte[] buffer = new byte[bufferLen];
			int bytesRead;

			do
			{
				// read a chunk of data from the input file 
				bytesRead = fsIn.Read(buffer, 0, bufferLen);

				// Decrypt it 
				cs.Write(buffer, 0, bytesRead);

			} while (bytesRead != 0);

			// close everything 
			cs.Close(); // this will also close the unrelying fsOut stream 
			fsIn.Close();
		}

		//		}

		#endregion
	}
}